# lab1
* 初始化堆栈到临时存储区，初始化中断向量表，设置定时器并在时钟中断的时候打印定时器信息
* 因为v9不支持类似x86的ebp指针，在函数调用的过程中，只有pc被入栈，所以函数在没有执行到上次以调用的返回点的时候并不知道上一次调用栈帧的位置

# lab2
* kalloc和kfree采用类似于first-fit的方法分配空闲页。```alloc_check```用于测试该函数的正确性
* ```setupkvm```用于初始化kernel的page table，建立从0xc0000000之后```mem_sz```大小的虚拟空间到0x00000000之后```mem_sz```大小物理空间的对等映射
* ```mappage```提供建立一个新映射的功能，如果对应的PT不存在，则创建之

# lab3
* 处理了缺页异常．在缺页时检查访问的地址是否合法，如果合法，则分配新页

# lab4
* 增加```fork_kthread```函数用于创建一个内核线程

# lab5
* 为了在没有文件系统的情况下存储用户程序，定义了一个全局变量```user_program```，```os.c```编译后，user_program将成为elf文件data段的一部分．这时可以将其替换为制定的用户程序．
```add_program.cpp```实现了该功能．该程序的作用是，查找一个magic string，如果找到，就把magic string所在的存储区替换为用户程序．同时应当将```user_program```初始化为以magic string开头使得这段存储可以被找到．
为了避免错误，应当检查magic string出现的唯一性，并且检查存储区大小足够存放用户程序
* 修改```exec```使之从```user_program```中读取程序而不是文件系统
* 增加系统调用```yield```，进程可以通过该调用主动放弃CPU使用权
* 实现测试样例```lab5_user.c```，样例通过fork创建８个用户进程，并通过yield轮流执行，同时测试在进程程序结束时可以顺利终止

# lab6
* 在lab5的基础上采用RR的方法调度进程

# lab7
*  实现了用户信号量以及对应的系统调用．调用```seminit```在内核存储去创建一个信号量，```semup```释放一个信号量或唤醒一个等待进程，```semdown```获取一个信号量或者进入等待
* 在```lab7_user.c```中实现了一个简单的测试．如果去掉```semup```和```semdown```的保护，输出会变得混乱没有规律

# lab8
* 该lab即把原先对lab新增的功能做细微修改并移植
